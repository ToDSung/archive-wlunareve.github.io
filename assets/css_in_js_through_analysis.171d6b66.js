import{o as s,b as e,q as c}from"./vendor.07cacaba.js";const o={class:"markdown-body"},t=c('<h1>css in js 全面解析 筆記</h1><p><a href="https://css-tricks.com/a-thorough-analysis-of-css-in-js/">https://css-tricks.com/a-thorough-analysis-of-css-in-js/</a></p><h2>Common CSS-in-JS features</h2><h3>Scoped CSS</h3><p>CSS modules 首創 能夠給 class 獨特的名字， 好處是可以很好的避免 css 汙染，或是不用思考獨特的名字 命名不要把 css 的屬性加進去，這樣未來要改時，才不會發生奇怪的矛盾</p><h3>SSR (Server-Side Rendering)</h3><p>現代的 css 套件，都提供 server side rendenring</p><h3>Automatic vendor prefixes</h3><p>不同的瀏覽器針對非標準 css spec 會有各自的名稱 這些新的現代框架，可以讓你寫最基本的 css，打包完成後就自動補上支援各瀏覽器的 css</p><p><img src="https://i.imgur.com/rz07trV.png" alt=""></p><h3>No inline styles</h3><p>目前不建議使用 style 的方式加入 css 主要是會有效能的考量</p><h3>Full CSS support</h3><p>所有的 css 框架，都提供包含</p><ul><li>(偽元素) pseudo classes and elements;</li><li>(RWD) media queries;</li><li>(動畫) keyframe animations.</li></ul><h2>Differentiating features</h2><h3>Styles/Component co-location</h3><p>選擇框架時，需要考量當 css 寫在與 html js 相同的檔案時， 有沒有能夠解析的能力</p><h3>Styles definition syntax</h3><p>不是每個框架都能夠支援多種的撰寫方式，需要思考哪種思考方式更適合，通常可以考慮</p><ul><li>編輯器的補充語法解析能力</li><li>編輯器的語法顯示，是不是能夠幫助成刺馬更易讀</li></ul><h4>template literal base</h4><pre><code class="language-javascript=">const heading = css`\n  font-size: 2em;\n  color: ${myTheme.color};\n`;\n</code></pre><h4>object base</h4><pre><code class="language-javascript=">const heading = css({\n  fontSize: &quot;2em&quot;,\n  color: myTheme.color,\n});\n</code></pre><h3>Styles output</h3><h4><code>&lt;style&gt;</code></h4><p>輸出是包在同個檔案之中以 <code>&lt;style&gt;</code> 的方式 好處是可以減少讀取的速度，render 的速度會更快</p><h4>css output</h4><p>輸出以獨立檔案 css 包的方式 SSR 可以選擇這個，可以更方便的套用快取</p><h3>Atomic CSS</h3><p>可以把重複的 css style 都包裝成單一的 class 缺點是在看網頁時的 dev tool 不好觀察 優點是大大降低 css 的大小</p><h2>conclusion</h2><p>要思考選擇的 css in js 框架我們可以考慮以下幾點</p><h3>我們是否使用 REACT 或是任何其他框架?</h3><p>當然有使用網頁框架的話，必須選擇能夠支援的 css in js 框架</p><h3>我們是否是一個有高度互動， SPA APP?</h3><p>是的話就做好 lazy loading 的工作，不需要將 css 變成單一檔案</p><h3>我們是否是一個 SSR 網站?</h3><p>把程式變成 css 檔案，可以更好的套用快取功能</p><h3>我們是否經常更新 style?</h3><p>常更新的話，提供快取功能的功能需求就較小了。</p><h3>我們是否重複使用了很多樣式和組件？</h3><p>使用 Atomic css 可以非常好的解決問題 筆者駐我認為像 Tailwind css 就是以這種方式進行處理的</p>',44),p={setup:(c,{expose:p})=>(p({frontmatter:{}}),(c,p)=>(s(),e("div",o,[t])))};export default p;
